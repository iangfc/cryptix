package cryptix.alg.chacha;

import cryptix.crypto.X;
import webfunds.util.Hex;
import webfunds.util.Panic;



/**
 * Test to push known good test vectors through Salsa20.
 * 
 * @author iang
 */
public class Salsa20Test
{
    static int verbose = 2; 
    
	
	/**
	 * This method will be called by outside testers, standard signature.
	 * @return a string with an error diag if it failed, else empty "" string.
	 */
	public static String selfTest() {
		
	    String s = "";
	    //s += selfTest(vectors128); // does not work for 128bit keys
        s += selfTest(Salsa20Vectors.vectors256);
	    return s;
	}

    public static String selfTest(String[][] vectors) {
        
        int q = vectors.length;
        
        String s = "";
        
        for (int i = 0; i < q; i++) {

            String[] v = vectors[i];
            if (verbose >= 4) {
                System.err.print(v[0] + ((verbose == 2) ? "" : ":\n"));
            }
            
            long startCycle = System.nanoTime();
            selfTest(v);
            long lenCycle = System.nanoTime() - startCycle;
            s += "\n    " + v[0] + " == " + lenCycle + "ns";
            
//            if (s != null) {
//                return s + "\nns:  " + lenCycle;
//            }
            if (verbose >= 3) {
                System.err.println(((verbose==2) ? "" : v[0]) + " -- " + lenCycle + "ns");
            }
            
        }
        
        return "salsa20 on ECrypt Vectors: worked for " + q + " vectors" + s;
    }

	private static void selfTest(String[] vector) {
		String s = "";

		byte[] key        = Hex.hex2data(vector[1]);     // byte[256 / 8];
		byte[] iv         = Hex.hex2data(vector[2]);     // byte[64  / 8];
		byte[] stream0    = Hex.hex2data(vector[3]);     // byte[512 / 8] ..
		byte[] stream192  = Hex.hex2data(vector[4]);
		byte[] stream256  = Hex.hex2data(vector[5]);
		byte[] stream448  = Hex.hex2data(vector[6]);
		byte[] xor_digest = Hex.hex2data(vector[7]);  // byte[512/8]
		
		/*
	     * How to use xor-digest
         * 
         * https://www.cosic.esat.kuleuven.be/nessie/testvectors/
         * has info on how to use it:
         * 
         *    stream[ ... ]xored is a "xor digest" of the whole 
         *    generated stream, where byte [i] of stream[...]xored is 
         *    the xor of stream[i+0], stream[i+64], stream[i+128], etc.
         *    
         *    
         *    (stream is generated by encrypting 512 zero bytes)
         *    http://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/salsa20/full/verified.test-vectors?rev=161&view=markup
	     */
		
		s += "key : " + Hex.data2hex(key) + "\n";
		s += "iv  : " + Hex.data2hex(iv) + "\n\n";
		
		byte[] message    = new byte[512];  // input stream of 512 zero bytes
        byte[] ciphertext = new byte[512];  // output stream of 512 encrypted bytes
		
                                //output,     input,   length of input
        s += "mesg: " + Hex.data2hex(message) + "\n";
		MySalsa20.crypto_stream_xor(ciphertext, message, message.length, iv, 0, key);
		s += "ciph: " + Hex.data2hex(ciphertext) + "\n";
		
		/*
		 * Within the ECRYPT Stream test vector are 4 snippets
		 * of encrypted data, to be found at different positions
		 * in the ciphertext of a 512byte empty message.
		 */
		//Equals.setNoisy();
		String result = "";

        result += testAgainstECRYPTTestVector(ciphertext, 0  , stream0  );
        result += testAgainstECRYPTTestVector(ciphertext, 192, stream192);
        result += testAgainstECRYPTTestVector(ciphertext, 256, stream256);
        
		
		// force an error to check comparisons: stream448[3] = 'x';
        result += testAgainstECRYPTTestVector(ciphertext, 448, stream448);
        if (result.length() > 0)     // oops!
            throw new Panic(s + result);
        
        byte[] decrypted = new byte[512];
        MySalsa20.crypto_stream_xor(decrypted, ciphertext, ciphertext.length, iv, 0, key);
        s += "decr: " + Hex.data2hex(decrypted) + "\n";
        if (! X.ctEquals(decrypted, message)) {
            s += "decrypt phase did not return all empty input:";
            throw new Panic(s);
            //return s;
        }
        
        if (verbose >= 3) {
            System.err.println(s);
        }
        
        byte[] ct_digest = xor_digest(ciphertext);
        
        if(!X.ctEquals(xor_digest, ct_digest)) {
            System.err.println(s);
        	throw new Panic("The digests don't match!!!!!!" +
        			"\ntheirs " + Hex.data2hex(xor_digest)+
        			"\nmine   " + Hex.data2hex(ct_digest));
        }
        
		return ;
	}

//	private static boolean _noisy = true;
//    /**
//     *  Display a diag on the screen if noise is turned on.
//     */
//    private static boolean noisy(String s)
//    {
//        if (_noisy)
//        {
//            System.err.println("NOISE: " + s);
//        }
//        return false;
//    }


	
	private static byte[] xor_digest( byte[] ct){
	    final int stream_size = 512;
		final int block_sz = 64;
		
		if( ct.length != stream_size)
			throw new RuntimeException("CT IS THE WRONG LENGTH!!!!");
		
		
		byte[] digest = new byte[block_sz];
		//this one goes across all 64 columns
		for( int i=0; i<block_sz; i++){
			//this takes the xor of every column
			byte column = 0;
			
			//collom = (byte) (ct[i] ^ ct[i+block_sz] ^ ct[i+(block_sz*2)] ^ ct[i+(block_sz*3)] ^ ct[i+(block_sz*4)] ^ 
				//				ct[i+(block_sz*5)] ^ ct[i+(block_sz*6)] ^ ct[i+(block_sz*7)]);
			
			
			for(int j = i; j<stream_size; j+=block_sz)
				column = (byte) (column ^ ct[j]);
			
			digest[i] = column;
		}
		
		return digest;
	}
	
	/**
	 * Compare a part of the ciphertext stream with a test vector snippet
	 * 
	 * @param c is the full ciphertext stream
	 * @param pos is the starting position of the snippet of test vector
	 * @param snippet is the text vector
	 * @return empty string "" if good, else a diagnostic to print out
	 */
	private static String testAgainstECRYPTTestVector(byte[] c, int pos, byte[] snippet) {

        int len = snippet.length;
        if (! X.ctEquals(c, pos, snippet, 0, len)) {
            String s = "snip: " + gapx2(pos) + Hex.data2hex(snippet) + "\n";
            return "Stream " + pos + " failed:\n" + s;
        }
        if (verbose >= 4)
            System.err.println("snip: " + gapx2(pos) + Hex.data2hex(snippet));
        return "";
	}
	
	
	
	public static String gapx2(int len) {
	    StringBuffer b = new StringBuffer();
	    for (int i = 0; i < len; i++) {
	        b.append("  ");
	    }
	    return b.toString();
	}
	
	
	
	public static void main(String[] args) {
        System.out.println(selfTest());
		System.exit(0);
	}
}