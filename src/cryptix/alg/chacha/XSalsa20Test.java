package cryptix.alg.chacha;


import cryptix.X;

/**
 * Test to push Crypto++ test vectors through XSalsa20.
 * @author AdaLovelace561
 *
 */
public class XSalsa20Test
{
	    private static int verbose = 2; 
	    		
		/**
		 * This method will be called by outside testers, standard signature.
		 * @return a string with an informative diag on success
		 * @throws some exception on fail
		 */
		public static String selfTest() {
			
		    String s = "";
		    //s += selfTest(vectors128); // does not work for 128bit keys
	        s += selfTest(XSalsa20Vectors.vectors256);
		    return s;
		}

	    public static String selfTest(String[][] vectors) {
	        
	        int q = vectors.length;
	        if (verbose >= 3)
                System.err.println("vector's len; "+ q);
	        String out = "";
	        
	        for (int i = 0; i < q; i++) {

	            String[] v = vectors[i];
	            if (verbose >= 3) {
	                System.err.print(v[0] + ((verbose == 2) ? "" : ":\n"));
	            } else {
	                out += i + ": " + X.quick(X.hex2data(v[1]));
	            }
	            
	            long startCycle = System.nanoTime();
	            String s;
	            if (i == 0)
	                 s = selfTest0(v);
	            else
		             s = selfTest1(v);
	            long lenCycle = System.nanoTime() - startCycle;
	            
	            if (s != null) {
	                return s + "\nns:  " + lenCycle;
	            }
	            if (verbose >= 4) {
	                System.err.println(((verbose==2) ? "" : v[0]) + " -- " + lenCycle + "ns");
	            }
	            
	        }
	        
	        return "worked for " + q + " vectors; " + out;
	    }
	    
	  //pt == vector[3]
		private static String selfTest1(String[] vector) {
			String s = "";
			byte[] key        = X.hex2data(vector[1]);
			byte[] iv         = X.hex2data(vector[2]);
			byte[] pt    	  = X.hex2data(vector[3]);   
			byte[] ct  		  = X.hex2data(vector[4]);
			if (verbose >= 4) System.err.println(" ");

			/*
		     * How to use xor-digest
	         * 
	         * https://www.cosic.esat.kuleuven.be/nessie/testvectors/
	         * has info on how to use it:
	         * 
	         *    stream[ ... ]xored is a "xor digest" of the whole 
	         *    generated stream, where byte [i] of stream[...]xored is 
	         *    the xor of stream[i+0], stream[i+64], stream[i+128], etc.
	         *    
	         *    
	         *    (stream is generated by encrypting 512 zero bytes)
	         *    http://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/XSalsa20/full/verified.test-vectors?rev=161&view=markup
		     */
			
			s += "key : " + X.data2hex(key) + "\n";
			s += "iv  : " + X.data2hex(iv) + "\n";
			s += "pt  : " + X.data2hex(pt)+" len "+pt.length+"\n\n";
			if (verbose >= 4) System.err.println("s\n" + s);
			
	        byte[] ciphertext = new byte[pt.length];  // output stream of 512 encrypted bytes
			
			Xsalsa20.crypto_stream_xor(ciphertext, pt, pt.length, iv, key);
			s += "ct  : " +"\n\t" +X.data2hex(ciphertext) + "\n\t"+ X.data2hex(ciphertext) +"\n";
			
			/*
			 * Within the ECRYPT Stream test vector are 4 snippets
			 * of encrypted data, to be found at different positions
			 * in the ciphertext of a 512byte empty message.
			 */
			//Equals.setNoisy();
			if(!X.ctEquals(ct, ciphertext))
				throw new RuntimeException("ciphertexts are not equal: "+ "\n\t [" + ciphertext.length + "] " +X.data2hex(ciphertext) + "\n\t [" + ct.length + "] "+ X.data2hex(ct) +"\n");
	        
	        
	        
	        byte[] decrypted = new byte[pt.length];
	        Xsalsa20.crypto_stream_xor(decrypted, ciphertext, ciphertext.length, iv, key);
	        s += "decr: " + X.data2hex(decrypted) + "\n";
	        
	        if (!X.ctEquals(decrypted, pt)) 
	            throw new RuntimeException("plaintexts are not equal: "+ "\n\t" +X.data2hex(pt) + "\n\t"+ X.data2hex(decrypted) +"\n");
	       
	        if (verbose >= 3) System.err.println("IT WORKED!!!!");
	        if (verbose >= 4) {
	            System.err.println(s);
	        }
	        
			return null;
		}
	    //pt == new byte[vector[3]]
		private static String selfTest0(String[] vector) {
			String s = "";
			byte[] key        = X.hex2data(vector[1]);
			byte[] iv         = X.hex2data(vector[2]);
			if (verbose >= 4) System.err.println("\nThis is our vector 3: "+ vector[3]);
			int i = Integer.parseInt(vector[3]);
			if (verbose >= 4) System.err.println("This is our pt len: "+ i);
			byte[] pt    	  = new byte[i];   
			byte[] ct  		  = X.hex2data(vector[4]);
			if (verbose >= 4) System.err.println(" ");

			/*
		     * How to use xor-digest
	         * 
	         * https://www.cosic.esat.kuleuven.be/nessie/testvectors/
	         * has info on how to use it:
	         * 
	         *    stream[ ... ]xored is a "xor digest" of the whole 
	         *    generated stream, where byte [i] of stream[...]xored is 
	         *    the xor of stream[i+0], stream[i+64], stream[i+128], etc.
	         *    
	         *    
	         *    (stream is generated by encrypting 512 zero bytes)
	         *    http://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/XSalsa20/full/verified.test-vectors?rev=161&view=markup
		     */
			
			s += "key : " + X.data2hex(key) + "\n";
			s += "iv  : " + X.data2hex(iv) + "\n";
			s += "pt  : " + X.data2hex(pt)+" len "+pt.length+"\n\n";
			if (verbose >= 4) System.err.println("s\n" + s);
			
	        byte[] ciphertext = new byte[pt.length];  // output stream of 512 encrypted bytes
			
			Xsalsa20.crypto_stream_xor(ciphertext, pt, pt.length, iv, key);
			s += "ct  : " +"\n\t" +X.data2hex(ciphertext) + "\n\t"+ X.data2hex(ciphertext) +"\n";
			
			/*
			 * Within the ECRYPT Stream test vector are 4 snippets
			 * of encrypted data, to be found at different positions
			 * in the ciphertext of a 512byte empty message.
			 */
			//Equals.setNoisy();
			if(!X.ctEquals(ct, ciphertext))
				throw new RuntimeException("ciphertexts are not equal: "+ "\n\t [" + ciphertext.length + "] " +X.data2hex(ciphertext) + "\n\t [" + ct.length + "] "+ X.data2hex(ct) +"\n");
	        
	        
	        
	        byte[] decrypted = new byte[pt.length];
	        Xsalsa20.crypto_stream_xor(decrypted, ciphertext, ciphertext.length, iv, key);
	        s += "decr: " + X.data2hex(decrypted) + "\n";
	        
	        if (!X.ctEquals(decrypted, pt)) 
	            throw new RuntimeException("plaintexts are not equal: "+ "\n\t" +X.data2hex(pt) + "\n\t"+ X.data2hex(decrypted) +"\n");
	       
	        if (verbose >= 3) System.err.println("IT WORKED!!!!");
	        if (verbose >= 4) {
	            System.err.println(s);
	        }
	        
			return null;
		}

		
//		private static byte[] xor_digest( byte[] ct){
//		    final int stream_size = 512;
//			final int block_sz = 64;
//			
//			if( ct.length != stream_size)
//				throw new RuntimeException("CT IS THE WRONG LENGTH!!!!");
//			
//			
//			byte[] digest = new byte[block_sz];
//			//this one goes across all 64 columns
//			for( int i=0; i<block_sz; i++){
//				//this takes the xor of every column
//				byte column = 0;
//
//				for(int j = i; j<stream_size; j+=block_sz)
//					column = (byte) (column ^ ct[j]);
//				
//				digest[i] = column;
//			}
//			
//			return digest;
//		}
		
//		/**
//		 * Compare a part of the ciphertext stream with a test vector snippet
//		 * 
//		 * @param c is the full ciphertext stream
//		 * @param pos is the starting position of the snippet of test vector
//		 * @param snippet is the text vector
//		 * @return empty string "" if good, else a diagnostic to print out
//		 */
//		private static String testAgainstECRYPTTestVector(byte[] c, int pos, byte[] snippet) {
//
//	        int len = snippet.length;
//	        if (! X.ctEquals(len, c, pos, snippet, 0)) {
//	            String s = "snip: " + gapx2(pos) + X.data2hex(snippet) + "\n";
//	            return "Stream " + pos + " failed:\n" + s;
//	        }
//	        if (verbose >= 4)
//	            System.err.println("snip: " + gapx2(pos) + X.data2hex(snippet));
//	        return "";
//		}
//		
		

		public static String gapx2(int len) {
		    StringBuffer b = new StringBuffer();
		    for (int i = 0; i < len; i++) {
		        b.append("  ");
		    }
		    return b.toString();
		}



		public static void main(String[] args) {
		    if (verbose >= 1)
		        System.err.println("Test of XSalsa20");
		    System.out.println(selfTest());
		    System.exit(0);
		}
}
